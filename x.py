from collections import defaultdict
from enum import StrEnum
import csv


class AddressingMode(StrEnum):
    ZeroPage = "ZERO_PAGE"
    ZeroPageX = "ZERO_PAGE_X"
    ZeroPageY = "ZERO_PAGE_Y"
    Indirect = "INDIRECT"
    Immediate = "IMMEDIATE"
    Absolute = "ABSOLUTE"
    AbsoluteX = "ABSOLUTE_X"
    AbsoluteY = "ABSOLUTE_Y"
    XIndirect = "X_INDIRECT"
    IndirectY = "INDIRECT_Y"
    Accumulator = "ACCUMULATOR"
    Relative = "RELATIVE"
    Implied = "IMPLIED"


modes = {
    "zpg": AddressingMode.ZeroPage,
    "zpg,X": AddressingMode.ZeroPageX,
    "zpg,Y": AddressingMode.ZeroPageY, 
    "abs": AddressingMode.Absolute,
    "abs,X": AddressingMode.AbsoluteX,
    "abs,Y": AddressingMode.AbsoluteY,
    "ind": AddressingMode.Indirect,
    "X,ind": AddressingMode.XIndirect,
    "ind,Y": AddressingMode.IndirectY,
    "#": AddressingMode.Immediate,
    "A": AddressingMode.Accumulator,
    "rel": AddressingMode.Relative,
    "impl": AddressingMode.Implied
}


unique_modes = set()
unique_instructions = set()
export_only = {"LDX", "LDA", "JMP", "RTS"}

instruction_modes = defaultdict(list)
instruction_opcodes = dict()

with open('external/instructions.csv', 'r') as f:
    lines = list(csv.reader(f))

    for i in range(16):
        for j in range(16):
            n = i * 16 + j
            line = lines[i][j]
            if line == "---":
                continue
            op, mode = line.split()

            unique_instructions.add(op)

            if mode not in modes:
                unique_modes.add(mode)

            if op in export_only:
                instruction_modes[op].append(modes[mode])
                instruction_opcodes[(op, modes[mode])] = n

assert len(unique_modes) == 0

print("Exporting... ")
print(", ".join(export_only))
print("Ignoring...")
print(", ".join(unique_instructions.difference(export_only)))


functions = []

cases = []

func_name = lambda op: f"chip_op_{op.lower()}"

for op in export_only:
    functions.append((func_name(op), instruction_modes[op]))

for op, modes in instruction_modes.items():

    if op in export_only:
        for mode in modes:
            n = instruction_opcodes[(op, mode)]
            s = f"""  case (0x{n:02X}): {{
    {func_name(op)}(self{f", ADDR_MODE_{mode}" if len(modes) > 1 else ""});
    break;
  }}"""
            cases.append(s)

functions = '\n\n'.join("static void " + f + f"(chip_t *{', addressing_mode_t' if len(modes) > 1 else ''});" for f, modes in functions)
cases = '\n'.join(cases)

instruction_lookup_template = f"""
#ifndef __SPACED_H__INSTRUCTION_LOOKUP__
#define __SPACED_H__INSTRUCTION_LOOKUP__

// This code is autogenerated using x.py
// Hopefully the massive switchcase gets optimized
// into a nice manageable table

#include "../defs.h"
#include "../addressing.h"
#include "../chip.h"

{functions}

static void chip_decode_execute(chip_t *self, byte opcode) {{
  switch (opcode) {{
{cases}
  }}
}}

#endif
""".strip()

with open('./src/generated/lookup.h', 'w+') as f:
    f.write(instruction_lookup_template)
